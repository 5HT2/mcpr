//! MCP Server Example using MCPR macros
//!
//! This example demonstrates how to use the MCPR macros to create a simple MCP server
//! with custom transports and tools.

use clap::Parser;
use log::info;
use mcpr::error::MCPError;
use mcpr::schema::common::{
    Prompt, PromptMessage, PromptMessageContent, Resource, ResourceContents, ResourceTemplate,
    Role, TextContent, TextResourceContents,
};
use mcpr_macros::{mcp_prompt, mcp_resource, mcp_server, mcp_transport, tool};
use serde::{Deserialize, Serialize};
use std::error::Error;

/// CLI arguments
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Enable debug output
    #[arg(short, long)]
    debug: bool,
}

// Define transport using the macro
#[mcp_transport(stdio)]
struct ServerTransport {
    // No need to define fields, they'll be generated by the macro
}

// Define a prompt provider using the macro
#[mcp_prompt]
struct ServerPromptProvider {
    // No need to define fields, they'll be generated by the macro
}

// Implement the PromptProvider trait since the macro no longer does this
impl mcpr::prompt::PromptProvider for ServerPromptProvider {
    fn get_prompts(&self) -> Vec<Prompt> {
        vec![
            Prompt {
                name: "system".to_string(),
                description: Some("System prompt for the assistant".to_string()),
                arguments: None,
            },
            Prompt {
                name: "user_greeting".to_string(),
                description: Some("Greeting for the user".to_string()),
                arguments: None,
            },
        ]
    }

    fn get_prompt_messages(&self, name: &str) -> Result<Vec<PromptMessage>, MCPError> {
        match name {
            "system" => Ok(vec![PromptMessage {
                role: Role::Assistant,
                content: PromptMessageContent::Text(TextContent {
                    r#type: "text".to_string(),
                    text: "You are a helpful assistant.".to_string(),
                    annotations: None,
                }),
            }]),
            "user_greeting" => Ok(vec![PromptMessage {
                role: Role::User,
                content: PromptMessageContent::Text(TextContent {
                    r#type: "text".to_string(),
                    text: "Hello! How can I help you today?".to_string(),
                    annotations: None,
                }),
            }]),
            _ => Err(MCPError::NotFound(format!("Prompt not found: {}", name))),
        }
    }
}

// Define a resource provider using the macro
#[mcp_resource]
struct ServerResourceProvider {
    // No need to define fields, they'll be generated by the macro
}

// Implement the ResourceProvider trait methods
impl mcpr::resource::ResourceProvider for ServerResourceProvider {
    fn get_resources(&self) -> Vec<Resource> {
        vec![
            Resource {
                uri: "mcpr://user_info".to_string(),
                name: "User Information".to_string(),
                description: Some("Information about the current user".to_string()),
                mime_type: Some("application/json".to_string()),
                size: None,
                annotations: None,
            },
            Resource {
                uri: "mcpr://product_info".to_string(),
                name: "Product Information".to_string(),
                description: Some("Information about the product".to_string()),
                mime_type: Some("application/json".to_string()),
                size: None,
                annotations: None,
            },
        ]
    }

    fn get_resource_templates(&self) -> Vec<ResourceTemplate> {
        vec![ResourceTemplate {
            uri_template: "mcpr://user/{id}".to_string(),
            name: "User Template".to_string(),
            description: Some("Template for accessing user information".to_string()),
            mime_type: Some("application/json".to_string()),
            annotations: None,
        }]
    }

    fn get_resource(&self, uri: &str) -> Result<ResourceContents, MCPError> {
        match uri {
            "mcpr://user_info" => {
                // Return user info
                let user_info = serde_json::json!({
                    "id": "user123",
                    "name": "Example User",
                    "email": "user@example.com"
                });

                Ok(ResourceContents::Text(TextResourceContents {
                    uri: uri.to_string(),
                    mime_type: Some("application/json".to_string()),
                    text: serde_json::to_string_pretty(&user_info)
                        .map_err(|e| MCPError::Serialization(e))?,
                }))
            }
            "mcpr://product_info" => {
                // Return product info
                let product_info = serde_json::json!({
                    "name": "MCPR Example Server",
                    "version": "0.1.0",
                    "build_date": "2023-09-01"
                });

                Ok(ResourceContents::Text(TextResourceContents {
                    uri: uri.to_string(),
                    mime_type: Some("application/json".to_string()),
                    text: serde_json::to_string_pretty(&product_info)
                        .map_err(|e| MCPError::Serialization(e))?,
                }))
            }
            _ => Err(MCPError::NotFound(format!("Resource not found: {}", uri))),
        }
    }

    // Return user info as a JSON value
    fn user_info(&self) -> serde_json::Value {
        serde_json::json!({
            "id": "user123",
            "name": "Example User",
            "email": "user@example.com"
        })
    }

    // Return product info as a JSON value
    fn product_info(&self) -> serde_json::Value {
        serde_json::json!({
            "name": "MCPR Example Server",
            "version": "0.1.0",
            "build_date": "2023-09-01"
        })
    }
}

// Define server using the macro
#[mcp_server]
struct Server {
    // No need to define fields, they'll be generated by the macro
}

// Define request/response types for the hello tool
#[derive(Debug, Clone, Serialize, Deserialize)]
struct HelloRequest {
    name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct HelloResponse {
    message: String,
}

// Define request/response types for the calculate tool
#[derive(Debug, Clone, Serialize, Deserialize)]
struct CalculateRequest {
    operation: String,
    a: f64,
    b: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct CalculateResponse {
    result: f64,
}

// Define tool functions as standalone functions with the tool macro
// Hello tool implementation using the tool macro
#[tool("hello")]
fn hello(request: HelloRequest) -> Result<HelloResponse, MCPError> {
    info!("Hello request for name: {}", request.name);
    Ok(HelloResponse {
        message: format!("Hello, {}!", request.name),
    })
}

// Calculate tool implementation using the tool macro
#[tool("calculate")]
fn calculate(request: CalculateRequest) -> Result<CalculateResponse, MCPError> {
    let result = match request.operation.as_str() {
        "add" => request.a + request.b,
        "subtract" => request.a - request.b,
        "multiply" => request.a * request.b,
        "divide" => {
            if request.b == 0.0 {
                return Err(MCPError::InvalidRequest("Division by zero".to_string()));
            }
            request.a / request.b
        }
        _ => {
            return Err(MCPError::InvalidRequest(format!(
                "Unknown operation: {}",
                request.operation
            )));
        }
    };

    info!(
        "Calculate request: {} {} {} = {}",
        request.a, request.operation, request.b, result
    );

    Ok(CalculateResponse { result })
}

// Simplified Server implementation
impl Server {
    // We can add methods here if needed, but keep tool functions outside
}

fn main() -> Result<(), Box<dyn Error>> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging
    if args.debug {
        std::env::set_var("RUST_LOG", "debug,mcpr=debug");
    } else {
        std::env::set_var("RUST_LOG", "info,mcpr=info");
    }
    env_logger::init();

    info!("Starting MCPR Example Server");

    // Create prompt provider
    let prompt_provider = ServerPromptProvider::new();

    // Create resource provider
    let resource_provider = ServerResourceProvider::new();

    // Create transport
    let transport = ServerTransport::stdin_stdout();

    // Create server using the builder pattern
    let mut server = Server::builder()
        .with_transport(transport)
        .with_prompt_provider(prompt_provider)
        .with_resource_provider(resource_provider)
        .with_protocol_version("2024-05-01")
        .with_server_info("mcpr-example-server", "0.1.0")
        .build();

    // Register our tool handlers
    server.tools_provider =
        Some(Box::new(CustomToolsProvider {}) as Box<dyn mcpr::tools::ToolsProvider>);

    // Start the server
    info!("Starting server...");
    server.start()?;
    info!("Server started successfully");

    // Run the server instead of waiting for shutdown
    // This processes messages in a loop and won't exit until properly shut down
    server.run()?;
    info!("Server shutdown complete");

    Ok(())
}

// Define our custom tools provider
struct CustomToolsProvider {}

impl mcpr::tools::ToolsProvider for CustomToolsProvider {
    fn get_tools(&self) -> Vec<mcpr::schema::common::Tool> {
        let mut tools = Vec::new();

        // Use our tool implementations
        hello::register_tool(&mut tools);
        calculate::register_tool(&mut tools);

        tools
    }

    fn execute_tool(
        &self,
        tool_name: &str,
        parameters: &serde_json::Value,
    ) -> Result<serde_json::Value, MCPError> {
        match tool_name {
            "hello" => {
                let request = serde_json::from_value::<HelloRequest>(parameters.clone())
                    .map_err(|e| MCPError::InvalidRequest(format!("Invalid parameters: {}", e)))?;

                let response = hello(request)?;
                serde_json::to_value(response).map_err(|e| MCPError::Serialization(e))
            }
            "calculate" => {
                let request = serde_json::from_value::<CalculateRequest>(parameters.clone())
                    .map_err(|e| MCPError::InvalidRequest(format!("Invalid parameters: {}", e)))?;

                let response = calculate(request)?;
                serde_json::to_value(response).map_err(|e| MCPError::Serialization(e))
            }
            _ => Err(MCPError::Protocol(format!("Unknown tool: {}", tool_name))),
        }
    }
}
