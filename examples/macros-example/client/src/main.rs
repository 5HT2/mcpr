//! MCP Client Example using MCPR macros
//!
//! This example demonstrates how to use the MCPR macros to create a simple MCP client
//! with custom transports and tool invocations.

use clap::Parser;
use log::{error, info};
use mcpr::error::MCPError;
use mcpr_macros::{mcp_client, mcp_transport, tool_call};
use serde::Deserialize;
use std::error::Error;
use std::process::{Command, Stdio};

/// CLI arguments
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Enable debug output
    #[arg(short, long)]
    debug: bool,

    /// Name to use in hello request
    #[arg(short, long, default_value = "MCPR User")]
    name: String,

    /// Connect to an already running server
    #[arg(long)]
    connect: bool,

    /// Path to server executable
    #[arg(long, default_value = "../../target/debug/mcpr-example-server")]
    server_path: String,

    /// Test mode - no actual server connection
    #[arg(long)]
    test_mode: bool,
}

// Define transport using the macro
#[mcp_transport(stdio)]
struct ClientTransport {
    // No fields needed, they'll be generated by the macro
}

// Define client using the client macro
#[mcp_client]
struct ExampleClient {
    // No fields needed, they'll be generated by the macro
}

// Define response types
#[derive(Debug, Deserialize)]
struct HelloResponse {
    message: String,
}

#[derive(Debug, Deserialize)]
struct CalculateResponse {
    result: f64,
}

// Add typed tool methods using tool_call attribute
impl ExampleClient {
    // Create a typed wrapper for the hello tool
    #[tool_call("hello")]
    fn hello(&mut self, name: String) -> Result<HelloResponse, MCPError> {}

    // Create a typed wrapper for the calculate tool
    #[tool_call("calculate")]
    fn calculate(
        &mut self,
        a: f64,
        b: f64,
        operation: String,
    ) -> Result<CalculateResponse, MCPError> {
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging
    if args.debug {
        std::env::set_var("RUST_LOG", "debug,mcpr=debug");
    } else {
        std::env::set_var("RUST_LOG", "info,mcpr=info");
    }
    env_logger::init();

    if args.test_mode {
        info!("Running in test mode - testing tool registration");
        // Test completed successfully
        return Ok(());
    }

    // Create transport based on args
    let transport = if args.connect {
        info!("Connecting to existing server via stdio");
        ClientTransport::stdin_stdout()
    } else {
        info!("Starting server process: {}", args.server_path);

        // Start the server process
        let server_process = Command::new(&args.server_path)
            .stdout(Stdio::piped())
            .stdin(Stdio::piped())
            .spawn()?;

        ClientTransport::from_process(server_process)?
    };

    // Create client with the transport
    let mut client = ExampleClient::new(transport);

    // Initialize the client
    info!("Initializing client...");
    match client.initialize() {
        Ok(server_info) => info!("Connected to server: {:?}", server_info),
        Err(e) => {
            error!("Failed to initialize connection: {:?}", e);
            return Err(Box::new(e));
        }
    }

    // List available tools from server
    info!("Getting available tools from server...");
    match client.get_tools() {
        Ok(tools) => {
            info!(
                "Available tools: {:?}",
                tools.iter().map(|t| &t.name).collect::<Vec<_>>()
            );
        }
        Err(e) => {
            error!("Failed to get tools: {:?}", e);
        }
    }

    // Call hello tool
    info!("Calling hello tool with name: {}", args.name);
    match client.hello(args.name.clone()) {
        Ok(response) => info!("Response: {}", response.message),
        Err(e) => error!("Hello tool call failed: {:?}", e),
    }

    // Call calculate tool
    info!("Calling calculate tool: 5 + 3");
    match client.calculate(5.0, 3.0, "add".to_string()) {
        Ok(response) => info!("Result of calculation: {}", response.result),
        Err(e) => error!("Calculate tool call failed: {:?}", e),
    }

    // List available prompts from server
    info!("Getting available prompts from server...");
    match client.get_prompts() {
        Ok(prompts) => {
            info!(
                "Available prompts: {:?}",
                prompts.iter().map(|p| &p.name).collect::<Vec<_>>()
            );
        }
        Err(e) => {
            error!("Failed to get prompts: {:?}", e);
        }
    }

    // List available resources from server
    info!("Getting available resources from server...");
    match client.get_resources() {
        Ok(resources) => {
            info!(
                "Available resources: {:?}",
                resources.iter().map(|r| &r.name).collect::<Vec<_>>()
            );
        }
        Err(e) => {
            error!("Failed to get resources: {:?}", e);
        }
    }

    // Disconnect from server
    info!("Disconnecting from server...");
    if let Err(e) = client.disconnect() {
        error!("Failed to disconnect: {:?}", e);
    }

    Ok(())
}
